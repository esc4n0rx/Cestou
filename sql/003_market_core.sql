-- 003_market_core.sql
-- Core tables for shopping lists, list items and inventory

create extension if not exists pgcrypto;

create table if not exists public.shopping_lists (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  name text not null,
  status text not null default 'draft' check (status in ('draft', 'shopping', 'completed')),
  source_list_id uuid references public.shopping_lists(id) on delete set null,
  started_at timestamptz,
  completed_at timestamptz,
  created_at timestamptz not null default timezone('utc'::text, now()),
  updated_at timestamptz not null default timezone('utc'::text, now())
);

create index if not exists shopping_lists_user_created_idx
on public.shopping_lists (user_id, created_at desc);

create table if not exists public.shopping_list_items (
  id uuid primary key default gen_random_uuid(),
  list_id uuid not null references public.shopping_lists(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  name text not null,
  category text not null default 'Outros',
  unit text not null default 'un',
  planned_quantity numeric(10,2) not null default 1 check (planned_quantity > 0),
  purchased_quantity numeric(10,2),
  unit_price numeric(10,2),
  is_purchased boolean not null default false,
  is_urgent boolean not null default false,
  position integer not null default 0,
  created_at timestamptz not null default timezone('utc'::text, now()),
  updated_at timestamptz not null default timezone('utc'::text, now()),
  check (purchased_quantity is null or purchased_quantity >= 0),
  check (unit_price is null or unit_price >= 0)
);

create index if not exists shopping_list_items_list_idx
on public.shopping_list_items (list_id, position, created_at);

create table if not exists public.inventory_items (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  name text not null,
  name_normalized text generated always as (lower(trim(name))) stored,
  category text not null default 'Outros',
  unit text not null default 'un',
  quantity numeric(10,2) not null default 0 check (quantity >= 0),
  low_threshold numeric(10,2) not null default 1 check (low_threshold >= 0),
  created_at timestamptz not null default timezone('utc'::text, now()),
  updated_at timestamptz not null default timezone('utc'::text, now()),
  unique (user_id, name_normalized, unit)
);

create index if not exists inventory_items_user_qty_idx
on public.inventory_items (user_id, quantity asc);

create table if not exists public.inventory_movements (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  inventory_item_id uuid not null references public.inventory_items(id) on delete cascade,
  source text not null check (source in ('list_purchase', 'manual_decrease', 'manual_adjustment', 'item_return')),
  delta numeric(10,2) not null,
  reference_list_id uuid references public.shopping_lists(id) on delete set null,
  reference_item_id uuid references public.shopping_list_items(id) on delete set null,
  created_at timestamptz not null default timezone('utc'::text, now())
);

create index if not exists inventory_movements_user_created_idx
on public.inventory_movements (user_id, created_at desc);

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = timezone('utc'::text, now());
  return new;
end;
$$;

drop trigger if exists set_shopping_lists_updated_at on public.shopping_lists;
create trigger set_shopping_lists_updated_at
before update on public.shopping_lists
for each row
execute function public.set_updated_at();

drop trigger if exists set_shopping_list_items_updated_at on public.shopping_list_items;
create trigger set_shopping_list_items_updated_at
before update on public.shopping_list_items
for each row
execute function public.set_updated_at();

drop trigger if exists set_inventory_items_updated_at on public.inventory_items;
create trigger set_inventory_items_updated_at
before update on public.inventory_items
for each row
execute function public.set_updated_at();

create or replace function public.sync_shopping_list_item_user_id()
returns trigger
language plpgsql
as $$
declare
  list_owner uuid;
begin
  select user_id into list_owner
  from public.shopping_lists
  where id = new.list_id;

  if list_owner is null then
    raise exception 'Shopping list not found';
  end if;

  new.user_id = list_owner;
  return new;
end;
$$;

drop trigger if exists sync_shopping_list_item_user_id on public.shopping_list_items;
create trigger sync_shopping_list_item_user_id
before insert or update on public.shopping_list_items
for each row
execute function public.sync_shopping_list_item_user_id();

create or replace function public.finalize_shopping_list(p_list_id uuid)
returns void
language plpgsql
security invoker
as $$
declare
  current_user_id uuid := auth.uid();
  list_owner_id uuid;
begin
  if current_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select user_id into list_owner_id
  from public.shopping_lists
  where id = p_list_id
  for update;

  if list_owner_id is null then
    raise exception 'List not found';
  end if;

  if list_owner_id <> current_user_id then
    raise exception 'You can only finalize your own list';
  end if;

  update public.shopping_lists
  set status = 'completed',
      completed_at = timezone('utc'::text, now()),
      updated_at = timezone('utc'::text, now())
  where id = p_list_id
    and user_id = current_user_id
    and status <> 'completed';

  with purchased_items as (
    select
      user_id,
      name,
      category,
      unit,
      sum(coalesce(purchased_quantity, 0)) as purchased_quantity
    from public.shopping_list_items
    where list_id = p_list_id
      and user_id = current_user_id
      and is_purchased = true
      and coalesce(purchased_quantity, 0) > 0
    group by user_id, name, category, unit
  ),
  upserted as (
    insert into public.inventory_items (user_id, name, category, unit, quantity)
    select
      user_id,
      name,
      category,
      unit,
      purchased_quantity
    from purchased_items
    on conflict (user_id, name_normalized, unit)
    do update
      set quantity = public.inventory_items.quantity + excluded.quantity,
          category = excluded.category,
          updated_at = timezone('utc'::text, now())
    returning id, user_id, name_normalized, unit
  ),
  movement_payload as (
    select
      ii.id as inventory_item_id,
      pi.user_id,
      pi.purchased_quantity as delta
    from purchased_items pi
    join public.inventory_items ii
      on ii.user_id = pi.user_id
     and ii.name_normalized = lower(trim(pi.name))
     and ii.unit = pi.unit
  )
  insert into public.inventory_movements (
    user_id,
    inventory_item_id,
    source,
    delta,
    reference_list_id
  )
  select
    mp.user_id,
    mp.inventory_item_id,
    'list_purchase',
    mp.delta,
    p_list_id
  from movement_payload mp
  where mp.delta > 0;
end;
$$;

create or replace function public.decrement_inventory_item(
  p_item_id uuid,
  p_amount numeric default 1
)
returns numeric
language plpgsql
security invoker
as $$
declare
  current_user_id uuid := auth.uid();
  old_quantity numeric;
  new_quantity numeric;
  delta_value numeric;
begin
  if current_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if p_amount <= 0 then
    raise exception 'Amount must be greater than zero';
  end if;

  select quantity into old_quantity
  from public.inventory_items
  where id = p_item_id
    and user_id = current_user_id
  for update;

  if old_quantity is null then
    raise exception 'Inventory item not found';
  end if;

  new_quantity := greatest(0, old_quantity - p_amount);

  update public.inventory_items
  set quantity = new_quantity,
      updated_at = timezone('utc'::text, now())
  where id = p_item_id
    and user_id = current_user_id;

  delta_value := new_quantity - old_quantity;

  if delta_value <> 0 then
    insert into public.inventory_movements (
      user_id,
      inventory_item_id,
      source,
      delta
    )
    values (
      current_user_id,
      p_item_id,
      'manual_decrease',
      delta_value
    );
  end if;

  return new_quantity;
end;
$$;
